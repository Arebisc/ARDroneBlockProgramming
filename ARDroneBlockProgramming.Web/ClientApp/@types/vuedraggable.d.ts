declare module 'vuedraggable' {

    /** Declaration file generated by dts-gen */

    export const name: string;

    export function beforeDestroy(): void;

    export function data(): any;

    export function mounted(): any;

    export function render(h: any): any;

    export namespace beforeDestroy {
        const prototype: {
        };

    }

    export namespace computed {
        function isCloning(): any;

        function realList(): any;

        function rootContainer(): any;

        namespace isCloning {
            const prototype: {
            };

        }

        namespace realList {
            const prototype: {
            };

        }

        namespace rootContainer {
            const prototype: {
            };

        }

    }

    export namespace data {
        const prototype: {
        };

    }

    export namespace methods {
        function alterList(onList: any): void;

        function computeFutureIndex(relatedContext: any, evt: any): any;

        function computeIndexes(): void;

        function emitChanges(evt: any): void;

        function getChildrenNodes(): any;

        function getComponent(): any;

        function getRelatedContextFromMoveEvent(_ref2: any): any;

        function getUnderlyingPotencialDraggableComponent(_ref: any): any;

        function getUnderlyingVm(htmlElt: any): any;

        function getVmIndex(domIndex: any): any;

        function onDragAdd(evt: any): void;

        function onDragEnd(evt: any): void;

        function onDragMove(evt: any, originalEvent: any): any;

        function onDragRemove(evt: any): void;

        function onDragStart(evt: any): void;

        function onDragUpdate(evt: any): void;

        function resetTransitionData(index: any): void;

        function spliceList(...args: any[]): any;

        function updatePosition(oldIndex: any, newIndex: any): any;

        namespace alterList {
            const prototype: {
            };

        }

        namespace computeFutureIndex {
            const prototype: {
            };

        }

        namespace computeIndexes {
            const prototype: {
            };

        }

        namespace emitChanges {
            const prototype: {
            };

        }

        namespace getChildrenNodes {
            const prototype: {
            };

        }

        namespace getComponent {
            const prototype: {
            };

        }

        namespace getRelatedContextFromMoveEvent {
            const prototype: {
            };

        }

        namespace getUnderlyingPotencialDraggableComponent {
            const prototype: {
            };

        }

        namespace getUnderlyingVm {
            const prototype: {
            };

        }

        namespace getVmIndex {
            const prototype: {
            };

        }

        namespace onDragAdd {
            const prototype: {
            };

        }

        namespace onDragEnd {
            const prototype: {
            };

        }

        namespace onDragMove {
            const prototype: {
            };

        }

        namespace onDragRemove {
            const prototype: {
            };

        }

        namespace onDragStart {
            const prototype: {
            };

        }

        namespace onDragUpdate {
            const prototype: {
            };

        }

        namespace resetTransitionData {
            const prototype: {
            };

        }

        namespace spliceList {
            const prototype: {
            };

        }

        namespace updatePosition {
            const prototype: {
            };

        }

    }

    export namespace mounted {
        const prototype: {
        };

    }

    export namespace props {
        class options {
            constructor(p0: any);

            // Native method; no parameter or return type inference available
            hasOwnProperty(p0: any): any;

            // Native method; no parameter or return type inference available
            isPrototypeOf(p0: any): any;

            // Native method; no parameter or return type inference available
            propertyIsEnumerable(p0: any): any;

            // Native method; no parameter or return type inference available
            toLocaleString(): any;

            // Native method; no parameter or return type inference available
            toString(): any;

            // Native method; no parameter or return type inference available
            valueOf(): any;

            static assign(p0: any, p1: any): any;

            static create(p0: any, p1: any): any;

            static defineProperties(p0: any, p1: any): any;

            static defineProperty(p0: any, p1: any, p2: any): any;

            static entries(p0: any): any;

            static freeze(p0: any): any;

            static getOwnPropertyDescriptor(p0: any, p1: any): any;

            static getOwnPropertyDescriptors(p0: any): any;

            static getOwnPropertyNames(p0: any): any;

            static getOwnPropertySymbols(p0: any): any;

            static getPrototypeOf(p0: any): any;

            static is(p0: any, p1: any): any;

            static isExtensible(p0: any): any;

            static isFrozen(p0: any): any;

            static isSealed(p0: any): any;

            static keys(p0: any): any;

            static preventExtensions(p0: any): any;

            static seal(p0: any): any;

            static setPrototypeOf(p0: any, p1: any): any;

            static values(p0: any): any;

        }

        namespace clone {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                apply(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                bind(p0: any): any;

                // Native method; no parameter or return type inference available
                call(p0: any): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                static prototype(): any;

            }

            namespace type {
                namespace prototype {
                    // Too-deep object hierarchy from vuedraggable.props.clone.type.prototype
                    const apply: any;

                    // Too-deep object hierarchy from vuedraggable.props.clone.type.prototype
                    const bind: any;

                    // Too-deep object hierarchy from vuedraggable.props.clone.type.prototype
                    const call: any;

                    // Too-deep object hierarchy from vuedraggable.props.clone.type.prototype
                    const toString: any;

                }

            }

        }

        namespace componentData {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                hasOwnProperty(p0: any): any;

                // Native method; no parameter or return type inference available
                isPrototypeOf(p0: any): any;

                // Native method; no parameter or return type inference available
                propertyIsEnumerable(p0: any): any;

                // Native method; no parameter or return type inference available
                toLocaleString(): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                // Native method; no parameter or return type inference available
                valueOf(): any;

                static assign(p0: any, p1: any): any;

                static create(p0: any, p1: any): any;

                static defineProperties(p0: any, p1: any): any;

                static defineProperty(p0: any, p1: any, p2: any): any;

                static entries(p0: any): any;

                static freeze(p0: any): any;

                static getOwnPropertyDescriptor(p0: any, p1: any): any;

                static getOwnPropertyDescriptors(p0: any): any;

                static getOwnPropertyNames(p0: any): any;

                static getOwnPropertySymbols(p0: any): any;

                static getPrototypeOf(p0: any): any;

                static is(p0: any, p1: any): any;

                static isExtensible(p0: any): any;

                static isFrozen(p0: any): any;

                static isSealed(p0: any): any;

                static keys(p0: any): any;

                static preventExtensions(p0: any): any;

                static seal(p0: any): any;

                static setPrototypeOf(p0: any, p1: any): any;

                static values(p0: any): any;

            }

            const required: boolean;

            namespace type {
                namespace prototype {
                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const hasOwnProperty: any;

                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const isPrototypeOf: any;

                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const propertyIsEnumerable: any;

                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const toLocaleString: any;

                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const toString: any;

                    // Too-deep object hierarchy from vuedraggable.props.componentData.type.prototype
                    const valueOf: any;

                }

            }

        }

        namespace element {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                anchor(p0: any): any;

                // Native method; no parameter or return type inference available
                big(): any;

                // Native method; no parameter or return type inference available
                blink(): any;

                // Native method; no parameter or return type inference available
                bold(): any;

                // Native method; no parameter or return type inference available
                charAt(p0: any): any;

                // Native method; no parameter or return type inference available
                charCodeAt(p0: any): any;

                // Native method; no parameter or return type inference available
                codePointAt(p0: any): any;

                // Native method; no parameter or return type inference available
                concat(p0: any): any;

                // Native method; no parameter or return type inference available
                endsWith(p0: any): any;

                // Native method; no parameter or return type inference available
                fixed(): any;

                // Native method; no parameter or return type inference available
                fontcolor(p0: any): any;

                // Native method; no parameter or return type inference available
                fontsize(p0: any): any;

                // Native method; no parameter or return type inference available
                includes(p0: any): any;

                // Native method; no parameter or return type inference available
                indexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                italics(): any;

                // Native method; no parameter or return type inference available
                lastIndexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                link(p0: any): any;

                // Native method; no parameter or return type inference available
                localeCompare(p0: any): any;

                // Native method; no parameter or return type inference available
                match(p0: any): any;

                // Native method; no parameter or return type inference available
                normalize(): any;

                // Native method; no parameter or return type inference available
                padEnd(p0: any): any;

                // Native method; no parameter or return type inference available
                padStart(p0: any): any;

                // Native method; no parameter or return type inference available
                repeat(p0: any): any;

                // Native method; no parameter or return type inference available
                replace(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                search(p0: any): any;

                // Native method; no parameter or return type inference available
                slice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                small(): any;

                // Native method; no parameter or return type inference available
                split(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                startsWith(p0: any): any;

                // Native method; no parameter or return type inference available
                strike(): any;

                // Native method; no parameter or return type inference available
                sub(): any;

                // Native method; no parameter or return type inference available
                substr(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                substring(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                sup(): any;

                // Native method; no parameter or return type inference available
                toLocaleLowerCase(): any;

                // Native method; no parameter or return type inference available
                toLocaleUpperCase(): any;

                // Native method; no parameter or return type inference available
                toLowerCase(): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                // Native method; no parameter or return type inference available
                toUpperCase(): any;

                // Native method; no parameter or return type inference available
                trim(): any;

                // Native method; no parameter or return type inference available
                trimLeft(): any;

                // Native method; no parameter or return type inference available
                trimRight(): any;

                // Native method; no parameter or return type inference available
                valueOf(): any;

                static fromCharCode(p0: any): any;

                static fromCodePoint(p0: any): any;

                static raw(p0: any): any;

            }

            namespace type {
                namespace prototype {
                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const anchor: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const big: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const blink: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const bold: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const charAt: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const charCodeAt: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const codePointAt: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const concat: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const endsWith: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const fixed: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const fontcolor: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const fontsize: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const includes: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const indexOf: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const italics: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const lastIndexOf: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const length: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const link: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const localeCompare: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const match: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const normalize: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const padEnd: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const padStart: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const repeat: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const replace: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const search: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const slice: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const small: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const split: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const startsWith: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const strike: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const sub: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const substr: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const substring: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const sup: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const toLocaleLowerCase: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const toLocaleUpperCase: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const toLowerCase: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const toString: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const toUpperCase: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const trim: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const trimLeft: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const trimRight: any;

                    // Too-deep object hierarchy from vuedraggable.props.element.type.prototype
                    const valueOf: any;

                }

            }

        }

        namespace list {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                concat(p0: any): any;

                // Native method; no parameter or return type inference available
                copyWithin(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                entries(): any;

                // Native method; no parameter or return type inference available
                every(p0: any): any;

                // Native method; no parameter or return type inference available
                fill(p0: any): any;

                // Native method; no parameter or return type inference available
                filter(p0: any): any;

                // Native method; no parameter or return type inference available
                find(p0: any): any;

                // Native method; no parameter or return type inference available
                findIndex(p0: any): any;

                // Native method; no parameter or return type inference available
                forEach(p0: any): any;

                // Native method; no parameter or return type inference available
                includes(p0: any): any;

                // Native method; no parameter or return type inference available
                indexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                join(p0: any): any;

                // Native method; no parameter or return type inference available
                keys(): any;

                // Native method; no parameter or return type inference available
                lastIndexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                map(p0: any): any;

                // Native method; no parameter or return type inference available
                pop(): any;

                // Native method; no parameter or return type inference available
                push(p0: any): any;

                // Native method; no parameter or return type inference available
                reduce(p0: any): any;

                // Native method; no parameter or return type inference available
                reduceRight(p0: any): any;

                // Native method; no parameter or return type inference available
                reverse(): any;

                // Native method; no parameter or return type inference available
                shift(): any;

                // Native method; no parameter or return type inference available
                slice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                some(p0: any): any;

                // Native method; no parameter or return type inference available
                sort(p0: any): any;

                // Native method; no parameter or return type inference available
                splice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                toLocaleString(): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                // Native method; no parameter or return type inference available
                unshift(p0: any): any;

                static from(p0: any): any;

                static isArray(p0: any): any;

                static of(): any;

                static prototype: any[];

            }

            const required: boolean;

        }

        namespace move {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                apply(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                bind(p0: any): any;

                // Native method; no parameter or return type inference available
                call(p0: any): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                static prototype(): any;

            }

            namespace type {
                namespace prototype {
                    // Too-deep object hierarchy from vuedraggable.props.move.type.prototype
                    const apply: any;

                    // Too-deep object hierarchy from vuedraggable.props.move.type.prototype
                    const bind: any;

                    // Too-deep object hierarchy from vuedraggable.props.move.type.prototype
                    const call: any;

                    // Too-deep object hierarchy from vuedraggable.props.move.type.prototype
                    const toString: any;

                }

            }

        }

        namespace noTransitionOnDrag {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                toString(): any;

                // Native method; no parameter or return type inference available
                valueOf(): any;

            }

            namespace type {
                namespace prototype {
                    // Too-deep object hierarchy from vuedraggable.props.noTransitionOnDrag.type.prototype
                    const toString: any;

                    // Too-deep object hierarchy from vuedraggable.props.noTransitionOnDrag.type.prototype
                    const valueOf: any;

                }

            }

        }

        namespace options {
            namespace prototype {
                function hasOwnProperty(p0: any): any;

                function isPrototypeOf(p0: any): any;

                function propertyIsEnumerable(p0: any): any;

                function toLocaleString(): any;

                function toString(): any;

                function valueOf(): any;

            }

        }

        namespace value {
            class type {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                concat(p0: any): any;

                // Native method; no parameter or return type inference available
                copyWithin(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                entries(): any;

                // Native method; no parameter or return type inference available
                every(p0: any): any;

                // Native method; no parameter or return type inference available
                fill(p0: any): any;

                // Native method; no parameter or return type inference available
                filter(p0: any): any;

                // Native method; no parameter or return type inference available
                find(p0: any): any;

                // Native method; no parameter or return type inference available
                findIndex(p0: any): any;

                // Native method; no parameter or return type inference available
                forEach(p0: any): any;

                // Native method; no parameter or return type inference available
                includes(p0: any): any;

                // Native method; no parameter or return type inference available
                indexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                join(p0: any): any;

                // Native method; no parameter or return type inference available
                keys(): any;

                // Native method; no parameter or return type inference available
                lastIndexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                map(p0: any): any;

                // Native method; no parameter or return type inference available
                pop(): any;

                // Native method; no parameter or return type inference available
                push(p0: any): any;

                // Native method; no parameter or return type inference available
                reduce(p0: any): any;

                // Native method; no parameter or return type inference available
                reduceRight(p0: any): any;

                // Native method; no parameter or return type inference available
                reverse(): any;

                // Native method; no parameter or return type inference available
                shift(): any;

                // Native method; no parameter or return type inference available
                slice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                some(p0: any): any;

                // Native method; no parameter or return type inference available
                sort(p0: any): any;

                // Native method; no parameter or return type inference available
                splice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                toLocaleString(): any;

                // Native method; no parameter or return type inference available
                toString(): any;

                // Native method; no parameter or return type inference available
                unshift(p0: any): any;

                static from(p0: any): any;

                static isArray(p0: any): any;

                static of(): any;

                static prototype: any[];

            }

            const required: boolean;

        }

    }

    export namespace render {
        const prototype: {
        };

    }

    export namespace watch {
        function realList(): void;

        namespace options {
            const deep: boolean;

            function handler(newOptionValue: any): void;

            namespace handler {
                const prototype: {
                };

            }

        }

        namespace realList {
            const prototype: {
            };

        }

    }

}